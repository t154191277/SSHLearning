// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}
// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}
// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}


// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}
// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}


// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}
// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}


// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}
// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}

// 实验2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<time.h>  
using namespace std;

#define MAX_KEY_NUM 5

typedef __int64 KEYTYPE;
typedef unsigned long FILEPtr;

typedef struct
{
	KEYTYPE key[MAX_KEY_NUM];
	FILEPtr Pointer[MAX_KEY_NUM + 1];
	int keyNum;
	bool isLeaf;
}BPlusNode;

typedef struct
{
	KEYTYPE key;
	FILEPtr Raddress;
}TRecord;

typedef struct
{
	bool exist;
	FILEPtr Naddress;
	FILEPtr Raddress;
}SearchResult;

class BPlusTree
{
	FILEPtr root;
	FILE *Bfile;
	FILE *Rfile;
public:
	FILEPtr GetBPlusNode() const;
	void ReadBPlusNode(const FILEPtr, BPlusNode&) const;
	void WriteBPlusNode(const FILEPtr, const BPlusNode&);

	void Build_BPlus_Tree();

	void Insert_BPlus_Tree(TRecord& );
	void insert_bplus_tree(FILEPtr, TRecord&);

	void Split_BPlus_Node(BPlusNode&, BPlusNode&, const int);

	void Search_BPlus_Tree(TRecord&, SearchResult&)const;

	void Delete_BPlus_Tree(TRecord&);
	void delete_BPlus_tree(FILEPtr, TRecord&);

	void EnumLeafKey();

	BPlusTree();
	~BPlusTree();
};

BPlusTree::BPlusTree()
{
	Bfile = fopen("Bfile", "rb+");
}

BPlusTree::~BPlusTree()
{
	fclose(Bfile);
}

void BPlusTree::Build_BPlus_Tree()
{
	root = GetBPlusNode();
	BPlusNode r;
	r.Pointer[MAX_KEY_NUM] = 0;
	r.keyNum = 0;
	r.isLeaf = true;
	WriteBPlusNode(root, r);
}

void BPlusTree::Insert_BPlus_Tree(TRecord &record)
{
	BPlusNode r;
	ReadBPlusNode(root, r);

	if ( r.keyNum == MAX_KEY_NUM )
	{
		BPlusNode newroot;
		newroot.keyNum = 0;
		newroot.isLeaf = false;
		newroot.Pointer[0] = root;

		Split_BPlus_Node(newroot, r, 0);
		WriteBPlusNode(root, r);

		root = GetBPlusNode();

		WriteBPlusNode(root, newroot);

	}
	insert_bplus_tree(root, record);
}

void BPlusTree::insert_bplus_tree(FILEPtr current, TRecord &record)
{
	BPlusNode x;
	ReadBPlusNode(current, x);

	int i;
	for (i = 0; i < x.keyNum&&x.key[i] < record.key; i++);
	
	if (i < x.keyNum &&x.isLeaf && x.key[i] == record.key)
	{
		return;
	}

	if (!x.isLeaf)
	{
		BPlusNode y;
		ReadBPlusNode(x.Pointer[i], y);

		if (y.keyNum == MAX_KEY_NUM) 
		{
			Split_BPlus_Node(x, y, i);
			WriteBPlusNode(current, x);
			WriteBPlusNode(x.Pointer[i], y);
		}

		if (record.key <= x.key[i] || i == x.keyNum)
		{
			insert_bplus_tree(x.Pointer[i], record);
		}
		else {
			insert_bplus_tree(x.Pointer[i + 1], record);
		}
	}
	else
	{
		for (int j = x.keyNum; j > i; j--)
		{
			x.key[j] = x.key[j - 1];
			x.Pointer[j] = x.Pointer[j - 1];
		}
		x.key[i] = record.key;
		x.keyNum++;

		x.Pointer[i] = record.Raddress;

		WriteBPlusNode(current, x);
	}
}

void BPlusTree::Split_BPlus_Node(BPlusNode &parrent, BPlusNode &current, const int childnum)
{
	int half = MAX_KEY_NUM / 2;
	
	int i;

	for (i = parrent.keyNum; i > childnum; i--)
	{
		parrent.key[i] = parrent.key[i - 1];
		parrent.Pointer[i + 1] = parrent.Pointer[i];
	}
	parrent.keyNum++;

	BPlusNode t;

	FILEPtr address = GetBPlusNode();

	parrent.key[childnum] = current.key[half];
	parrent.Pointer[childnum + 1] = address;

	for (i = half + 1; i < MAX_KEY_NUM; i++)
	{
		t.key[i - half - 1] = current.key[i];
		t.Pointer[i - half - 1] = current.Pointer[i];
	}

	t.keyNum = MAX_KEY_NUM - half - 1;
	t.Pointer[t.keyNum] = current.Pointer[MAX_KEY_NUM];

	t.isLeaf = current.isLeaf;

	current.keyNum = half;

	if (current.isLeaf)
	{
		current.keyNum++;
		t.Pointer[MAX_KEY_NUM] = current.Pointer[MAX_KEY_NUM];
		current.Pointer[MAX_KEY_NUM] = address;
	}

	WriteBPlusNode(address, t);
}

void BPlusTree::Search_BPlus_Tree(TRecord &record, SearchResult &result) const
{
	int i;

	BPlusNode a;
	FILEPtr current = root;

	do
	{
		ReadBPlusNode(current, a);

		for (i = 0; i < a.keyNum && record.key > a.key[i]; i++);

		if (i < a.keyNum && a.isLeaf && record.key == a.key[i])
		{
			result.Naddress = current;
			result.Raddress = a.Pointer[i];
			result.exist = true;

			return;
		}
		current = a.Pointer[i];
	} while (!a.isLeaf);

	result.exist = false;
}

void BPlusTree::Delete_BPlus_Tree(TRecord &record)
{
	delete_BPlus_tree(root, record);

	BPlusNode rootnode;
	ReadBPlusNode(root, rootnode);

	if (!rootnode.isLeaf && rootnode.keyNum == 0)
	{
		root = rootnode.Pointer[0];
	}
}

void BPlusTree::delete_BPlus_tree(FILEPtr current, TRecord &record)
{
	int i, j;

	BPlusNode x;
	ReadBPlusNode(current, x);


	for (i = 0; i < x.keyNum && record.key > x.key[i]; i++);

	if (i < x.keyNum && x.key[i] == record.key)  //在当前节点找到关键字  
	{

		if (!x.isLeaf)     //在内节点找到关键字  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (child.isLeaf)     //如果孩子是叶节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)      //情况A  
				{
					x.key[i] = child.key[child.keyNum - 2];
					child.keyNum--;

					WriteBPlusNode(current, x);
					WriteBPlusNode(x.Pointer[i], child);

					return;
				}
				else    //否则孩子节点的关键字数量不过半  
				{
					if (i > 0)      //有左兄弟节点  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)        //情况B  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}

							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];

							child.keyNum++;

							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							x.key[i] = child.key[child.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else    //情况C  
						{
							for (j = 0; j < child.keyNum; j++)
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child节点占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 2];

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}


					}
					else      //只有右兄弟节点  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)        //情况D  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}

							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else    //情况E  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;

							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}

				}

			}
			else      //情况F  
			{

				//找到key在B+树叶节点的左兄弟关键字,将这个关键字取代key的位置  

				TRecord trecord;
				trecord.key = record.key;
				SearchResult result;
				Search_BPlus_Tree(trecord, result);

				BPlusNode last;

				ReadBPlusNode(result.Naddress, last);

				x.key[i] = last.key[last.keyNum - 2];

				WriteBPlusNode(current, x);


				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}

			}

			delete_BPlus_tree(x.Pointer[i], record);

		}
		else  //情况G  
		{
			for (j = i; j < x.keyNum - 1; j++)
			{
				x.key[j] = x.key[j + 1];
				x.Pointer[j] = x.Pointer[j + 1];
			}
			x.keyNum--;

			WriteBPlusNode(current, x);

			return;
		}

	}
	else        //在当前节点没找到关键字     
	{
		if (!x.isLeaf)    //没找到关键字,则关键字必然包含在以Pointer[i]为根的子树中  
		{
			BPlusNode child;
			ReadBPlusNode(x.Pointer[i], child);

			if (!child.isLeaf)      //如果其孩子节点是内节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)        //情况H  
				{

				}
				else          //否则孩子节点的关键字数量不过半,则将兄弟节点的某一个关键字移至孩子  
				{
					if (i > 0)  //x.key[i]有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况I  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j + 1] = child.Pointer[j];
							}
							child.Pointer[1] = child.Pointer[0];
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum];

							child.keyNum++;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];
							lbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
						}
						else        //情况J  
						{
							lbchild.key[lbchild.keyNum] = x.key[i - 1];   //将孩子节点复制到其左兄弟的末尾  
							lbchild.keyNum++;

							for (j = 0; j < child.keyNum; j++)      //将child节点拷贝到lbchild节点的末尾,  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							lbchild.keyNum += child.keyNum;        //已经将child拷贝到lbchild节点  


															   //释放child节点的存储空间,x.Pointer[i]  


															   //将找到关键字的孩子child与关键字左兄弟的孩子lbchild合并后,将该关键字前移,使当前节点的关键字减少一个  
							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i - 1], lbchild);

							i--;

						}

					}
					else        //否则x.key[i]只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)     //情况K  
						{

							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							x.key[i] = rbchild.key[0];

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);

						}
						else        //情况L  
						{
							child.key[child.keyNum] = x.key[i];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum; j++)     //将rbchild节点合并到child节点后  
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.Pointer[child.keyNum + j] = rbchild.Pointer[j];

							child.keyNum += rbchild.keyNum;

							//释放rbchild节点所占用的空间,x,Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)    //当前将关键字之后的关键字左移一位,使该节点的关键字数量减一  
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);

						}

					}
				}
			}
			else  //否则其孩子节点是外节点  
			{
				if (child.keyNum > MAX_KEY_NUM / 2)  //情况M  
				{

				}
				else        //否则孩子节点不到半满  
				{
					if (i > 0) //有左兄弟  
					{
						BPlusNode lbchild;
						ReadBPlusNode(x.Pointer[i - 1], lbchild);

						if (lbchild.keyNum > MAX_KEY_NUM / 2)       //情况N  
						{
							for (j = child.keyNum; j > 0; j--)
							{
								child.key[j] = child.key[j - 1];
								child.Pointer[j] = child.Pointer[j - 1];
							}
							child.key[0] = x.key[i - 1];
							child.Pointer[0] = lbchild.Pointer[lbchild.keyNum - 1];
							child.keyNum++;
							lbchild.keyNum--;

							x.key[i - 1] = lbchild.key[lbchild.keyNum - 1];

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(x.Pointer[i], child);
							WriteBPlusNode(current, x);

						}
						else        //情况O  
						{

							for (j = 0; j < child.keyNum; j++)        //与左兄弟孩子节点合并  
							{
								lbchild.key[lbchild.keyNum + j] = child.key[j];
								lbchild.Pointer[lbchild.keyNum + j] = child.Pointer[j];
							}
							lbchild.keyNum += child.keyNum;

							lbchild.Pointer[MAX_KEY_NUM] = child.Pointer[MAX_KEY_NUM];

							//释放child占用的空间x.Pointer[i]  

							for (j = i - 1; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}

							x.keyNum--;

							WriteBPlusNode(x.Pointer[i - 1], lbchild);
							WriteBPlusNode(current, x);

							i--;

						}

					}
					else        //否则只有右兄弟  
					{
						BPlusNode rbchild;
						ReadBPlusNode(x.Pointer[i + 1], rbchild);

						if (rbchild.keyNum > MAX_KEY_NUM / 2)       //情况P  
						{
							x.key[i] = rbchild.key[0];
							child.key[child.keyNum] = rbchild.key[0];
							child.Pointer[child.keyNum] = rbchild.Pointer[0];
							child.keyNum++;

							for (j = 0; j < rbchild.keyNum - 1; j++)
							{
								rbchild.key[j] = rbchild.key[j + 1];
								rbchild.Pointer[j] = rbchild.Pointer[j + 1];
							}
							rbchild.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i + 1], rbchild);
							WriteBPlusNode(x.Pointer[i], child);

						}
						else        //情况Q  
						{
							for (j = 0; j < rbchild.keyNum; j++)
							{
								child.key[child.keyNum + j] = rbchild.key[j];
								child.Pointer[child.keyNum + j] = rbchild.Pointer[j];
							}
							child.keyNum += rbchild.keyNum;
							child.Pointer[MAX_KEY_NUM] = rbchild.Pointer[MAX_KEY_NUM];

							//释放rbchild占用的空间x.Pointer[i+1]  

							for (j = i; j < x.keyNum - 1; j++)
							{
								x.key[j] = x.key[j + 1];
								x.Pointer[j + 1] = x.Pointer[j + 2];
							}
							x.keyNum--;

							WriteBPlusNode(current, x);
							WriteBPlusNode(x.Pointer[i], child);


						}

					}

				}

			}

			delete_BPlus_tree(x.Pointer[i], record);
		}


	}
}

void BPlusTree::EnumLeafKey()
{
	BPlusNode head;

	ReadBPlusNode(root, head);

	while (!head.isLeaf)
	{
		ReadBPlusNode(head.Pointer[0], head);

	}

	while (1) {
		
		for (int i = 0; i < head.keyNum; i++) printf("%d\n", head.key[i]);
		if (head.Pointer[MAX_KEY_NUM] == 0) break;
		ReadBPlusNode(head.Pointer[MAX_KEY_NUM], head);
	}
}

inline void BPlusTree::ReadBPlusNode(const FILEPtr address, BPlusNode &r) const
{
	fseek(Bfile, address, SEEK_SET);
	fread((char*)(&r), sizeof(BPlusNode), 1, Bfile);
}

inline FILEPtr BPlusTree::GetBPlusNode() const
{
	fseek(Bfile, 0, SEEK_END);
	return ftell(Bfile);
}

inline void BPlusTree::WriteBPlusNode(const FILEPtr address, const BPlusNode &r) //将一个B+树节点写入address地址  
{
	fseek(Bfile, address, SEEK_SET);
	fwrite((char*)(&r), sizeof(BPlusNode), 1, Bfile);

}




int main()
{

	BPlusTree tree;

	tree.Build_BPlus_Tree();      //建树  

	TRecord record;   SearchResult result;

	int time1 = clock();

	int i;
	for (i = 0; i < 100000; i++)
	{
		record.key = i;
		tree.Insert_BPlus_Tree(record);
		//  printf("%d\n",i );  
	}

	for (i = 99997; i > 0; i--)
	{
		record.key = i;
		tree.Delete_BPlus_Tree(record);
		tree.Search_BPlus_Tree(record, result);
		if (result.exist)
			break;
		//  printf("%d\n",i);  
	}

	cout << clock() - time1 << endl;
	system("pause");
	tree.EnumLeafKey();

	tree.~BPlusTree();
	system("pause");
	return 0;
}



